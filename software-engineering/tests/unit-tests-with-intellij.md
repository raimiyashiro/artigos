# Unit Testing with IntelliJ Idea

## Introduction: Code is fragile
It's never too much to discuss the importance of writing tests before delivering any code.

If you are a developer, you should know one thing. Code is fragile. Code is fragile by itself. You know that as well as I know, and there isn't much we can do. A single line of code you deliver today can put you in big problems tomorrow: emergency calls, work on weekends, and the so-called, so-feared War Rooms! 

I hate being in a War-Room. It means poverty. Poor code. Poor deadlines. Garbage methodologies, often implemented by folks that don't know at all what agility means. Poor customers, not rarely. -- and other things that you can't control. Poor quality, which is not always on the *code*.

But there is a thing we can do, so the problem (GitHub blame) is not on our side. We can assure our teammates that the code we wrote today works fine in a couple of scenarios. It means that the code has a minimum of coverage, sufficient *Test Cases*, which assures that the code won't fail in some foreseen contexts when fed by a range of known parameters.

Let's start simple, covering the code with tests. Not only tests but Unit Tests. Well-written tests are most able to guarantee the *quality* of what we're delivering. Here, let me quote this:

> As the number of quality grows, the number of War-Rooms decreases.

Yep! Code is fragile. But I assure you that uncovered code is even worst.

## The principle of Unit Testing


// Great, now let's dive into the concept of unit testing.

## Isolation: testing methods independently with Mockito

## Plus: the Spy* case.

## Assertions and Coverage: covering the whole method with IntelliJ Idea

## Code Samples
